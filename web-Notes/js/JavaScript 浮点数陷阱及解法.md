---
title: JavaScript 浮点数陷阱及解法
---

原文地址：[https://zhuanlan.zhihu.com/p/30703042](https://zhuanlan.zhihu.com/p/30703042)

>JavaScript 浮点数运算时经常遇到会 0.000000001 和 0.999999999 这样奇怪的结果，如 0.1+0.2=0.30000000000000004、1-0.9=0.09999999999999998，很多人知道这是浮点数误差问题，但具体原因就说不清楚了。

## 一、浮点数的存储

首先要搞清楚 JavaScript 如何存储小数。和其它语言如 Java 和 Python 不同，JavaScript 中所有数字包括整数和小数都只有一种类型 — Number。它的实现遵循 IEEE 754 标准，使用 64 位固定长度来表示，也就是标准的 double 双精度浮点数（相关的还有float 32位单精度）。计算机组成原理中有过详细介绍，这里就不多介绍了。
>注：大多数语言中的小数默认都是遵循 IEEE 754 的 float 浮点数，包括 Java、Ruby、Python，本文中的浮点数问题同样存在。

这样的存储结构优点是可以归一化处理整数和小数，节省存储空间。

64位比特又可分为三个部分：
* 符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数
* 指数位E：中间的 11 位存储指数（exponent），用来表示次方数
* 尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零

![](./images/v2-7267a58b29892c3b723e3d6c3f73905a_hd.jpg)

实际数字就可以用以下公式来计算：
注意以上的公式遵循科学计数法的规范，在十进制中 0<M<10，到二进制就是 0<M<2。也就是说整数部分只能是1，所以可以被舍去，只保留后面的小数部分。如 4.5 转成二进制就是 100.1，科学计数法表示是 1.001 * 2^2，舍去1后 M = 001。E是一个无符号整数，因为长度是11位，取值范围是 0~2047。但是科学计数法中的指数是可以为负数的，所以约定减去一个中间数 1023，[0,102 ] 表示为负，[1024,2047] 表示为正。如 4.5 的指数 E = 1025，尾数 M = 001。
最终的公式变成：

![](./images/v2-2038480c70ce879e866767be10d74686_hd.jpg)

计算机 只认识 0 和 1，计算机 是先转为 二进制 后 再 计算 ，计算完成后 再转为 十进制。


例如：

* 为什么 0.1+0.2=0.30000000000000004？

  ```js
    // 0.1 和 0.2 都转化成二进制后再进行运算
	0.00011001100110011001100110011001100110011001100110011010 +
	0.0011001100110011001100110011001100110011001100110011010 =
	0.0100110011001100110011001100110011001100110011001100111
	// 转成十进制正好是 0.30000000000000004
  ```
  
  