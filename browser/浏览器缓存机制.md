---
title: 浏览器缓存机制
---

注意，我们讨论的所有关于缓存资源的问题，都仅仅针对GET请求。而对于POST, DELETE, PUT这类行为性操作通常不做任何缓存。

![浏览器请求静态资源的流程](https://user-gold-cdn.xitu.io/2017/9/25/c91480c8103aaa39fe7d000cc8f3aa59?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)


浏览器缓存的作用？
 * 加快页面打开速度
 * 降低服务器压力
 * 减少网络损耗


浏览器缓存有 **HTML Meta 标签** 控制与 **HTTP 头信息**控制两种。

## 一、html meta标签控制
```html?linenums
<meta http-equiv="Pragma" content="no-cache">
```

上述代码的作用是告诉浏览器当前页面不被缓存，所以每当需要请求该页面时都需要去服务器获取。

但由于仅有部分浏览器支持该标签，并且所有的缓存代理服务器均不支持，所以并未被广泛使用。

## 二、HTTP头信息控制

对于每次浏览器第一次HTTP请求来说，浏览器缓存中并不存在其请求资源相应的副本，这是浏览器便会向服务器发出HTTP请求来获取相应的请求结果，并根据缓存标识字段，来决定是否将请求结果作为副本存入浏览器缓存中。

HTTP 保持已缓存数据与服务器数据之间充分一致的机制称为**文档过期和服务器再验证**。而从浏览器缓存分类来看，也有将其分为**强制缓存**和**协商缓存**。

### 文档过期
当浏览器发起 HTTP 请求时，会根据浏览器缓存中的**缓存标识字段**来验证文档（资源副本）是否过期。
上述说的缓存标识字段便是 **Expires** 和 **Cache-Control**。

**Expires** 是服务器端在响应请求时用来规定资源的失效时间。

**Cache-Control**是服务器端在响应请求时用来规定资源是否需要被浏览器缓存以及缓存的有效时间等。

![](https://user-gold-cdn.xitu.io/2018/7/1/16454a13e8ae3a2c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

Cache-Control 主要取值如下：
 * public：所有内容都将被缓存（客户端和代理服务器都可缓存）
 * private：内容只缓存到私有缓存中（仅客户端可以缓存，代理服务器不可缓存）
* no-cache：必须先与服务器确认返回的响应是否被更改，然后才能使用该响应来满足后续对同一个网址的请求。因此，如果存在合适的验证令牌（ETag），no-cache 会发起往返通信来验证缓存的响应，如果资源未被更改，可以避免下载
* no-store：所有内容都不会被缓存或 Internet 临时文件中
* must-revalidation/proxy-revalidation：如果缓存的内容失效，请求必须发送到服务器/代理以进行重新验证
* max-age=xxx：缓存的内容将在 xxx 秒后失效

这里需要注意的是，no-cache 的作用是指跳过文档过期的验证而直接进行服务器再验证，而 no-store 是指资源禁止被缓存。

### 服务器再验证

在浏览器缓存中，还保存了其它关于资源副本的描述字段，这些字段都是服务器返回信息头带过来的，如 Last-Modified 和 Etag。

![](https://user-gold-cdn.xitu.io/2018/7/1/16454a13e89396c0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

